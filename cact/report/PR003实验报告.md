[TOC]

# 编译原理研讨课CACT实验PR003报告

## 成员组成

07组：

曾伟鸿 叶力汗 马艺豪

## 任务说明

本次实验是在前两次完成的基础上，进一步实现编译器的后端——将中间代码（IR）翻译为可在 RISC-V 架构下运行的汇编代码。具体任务包括：

1. 设计并实现 IR 到 RISC-V 汇编的转换流程，涵盖变量、表达式、控制流、函数调用等各类语句的指令生成。
2. 针对不同类型（整型、浮点型、布尔型、数组等）和作用域（全局、局部、临时变量），合理分配寄存器和内存，生成符合 RISC-V ABI 规范的汇编代码。
3. 支持数组、结构体、常量等数据的静态分配与初始化，正确生成 .data、.rodata 等数据段内容。
4. 实现函数栈帧管理、参数传递、返回值处理，保证函数调用与返回的正确性。
5. 生成的汇编代码需能通过 riscv64-unknown-linux-gnu-gcc 编译，并在 qemu-riscv64 环境下正确运行，支持 CACT 语言的全部功能样例。

通过本实验，要求掌握编译器后端的基本原理和实现方法，理解中间代码与目标机器代码之间的映射关系。


### 设计思路

**1. 浮点数、全局变量和局部数组初始值的处理**

- 浮点数：由于 RISC-V 汇编不能直接用立即数加载浮点常量，必须先在 `.rodata` 段为每个浮点常量分配一个标号和对应的值。汇编指令通过标号间接加载浮点数（如 `flw` 指令）。
- 全局变量：如果有初始值，则分配到 `.data` 段并写入初值；如果没有初始值，则分配到 `.bss` 段，仅分配空间不初始化。这样可以节省空间并保证数据段内容正确。
- 局部数组初值：对于有初始值的局部数组，也通过统一标号在数据段分配，汇编生成时只需一次性加载，避免多次读取基址，提升效率。
- 所有这些静态数据（浮点常量、全局变量、数组初值等）都先收集到 `Const_Stack`，最后统一输出到汇编文件的数据段，保证数据组织规范。


**2. 栈帧的计算**

- 栈帧是函数调用时用于保存局部变量、临时变量、参数等的内存空间。RISC-V ABI要求每个函数有独立的栈帧。
- 由于栈帧大小依赖于函数体内所有变量的分布，必须遍历整个函数的中间代码才能确定。编译器生成汇编时采用“两遍扫描”：
  - 第一遍：统计所有局部变量、临时变量和参数，计算所需栈空间，并记录每个变量在栈中的偏移位置。
  - 第二遍：根据中间代码类型生成汇编指令，利用第一遍记录的偏移信息，实现变量的正确存取和操作。
- 这样可以保证函数调用、返回、局部变量访问等都符合 RISC-V 的规范和实际需求。



**3. 不同类型变量的处理**

- 同一个中间代码操作（如加法、赋值等），根据变量类型（整型、浮点型、布尔型、数组等）会生成不同的汇编指令。
  - 例如：整型用 `lw`/`sw`，浮点型用 `flw`/`fsw`，布尔型用 `lb`/`sb`。
- 编译器通过中间代码中的 `basety` 字段判断变量类型，选择合适的指令，保证类型安全和指令正确性。这样可以支持多种数据类型的运算和存储。



**4. 子数组和数组元素的处理**

- 当中间代码操作对象为数组元素或子数组（即变量名为复合结构），需要特殊处理：
  - 解析变量名，计算出正确的偏移地址（如 `arr[i]` 的实际内存位置）。
  - 生成相应的加载和存储指令，保证数组访问的准确性和高效性。
- 这样可以支持复杂的数据结构和多维数组的操作，满足高级语言的表达能力。



## 实验过程

### 整体架构设计

将中间代码到RISC-V汇编代码的转换过程封装在`RiscvGen`类中。该类的设计分为两个主要文件：

- **RiscvGen.h**：定义`RiscvGen`类的接口，包含所有成员变量和成员函数的声明，为代码生成模块提供统一的对外接口
- **RiscvGen.cpp**：实现`RiscvGen`类的所有成员函数，包含具体的汇编代码生成逻辑

在主程序中，通过实例化`RiscvGen`类对象并调用其核心方法`Gen_All()`来启动整个汇编代码生成流程。该方法作为控制中心，协调所有子模块的工作，将中间代码逐步转换为符合RISC-V ABI规范的汇编指令，并最终输出到目标文件中。

### 核心实现函数

**Gen_All**

`Gen_All` 函数是整个代码生成过程的核心控制函数，采用**两遍扫描**的策略来处理中间代码到汇编代码的转换。

#### 初始化阶段
函数首先进行必要的初始化工作：
- 向 `ASM_array` 中添加汇编文件头信息（文件名等）
- 声明两个关键控制变量：
  - `rescan`：布尔标志，标记当前是第一次扫描（false）还是第二次扫描（true）
  - `rescan_loc`：整数变量，记录函数开始位置，用于第二次扫描时的回跳

#### 第一遍扫描：栈帧分析
在第一遍扫描中（`rescan == false`），主要目标是**分析和计算栈帧大小**：

```c++
case IR_G_ALLOC:
    Gen_G_Alloc(irc); // 处理全局变量分配
    break;
case IR_L_ALLOC:
    Cnt_Temp_Lvar(irc.result); // 统计局部变量空间需求
    break;
case IR_FUNC_BEGIN:
    frame_size = 16; // 初始化栈帧大小（预留返回地址和帧指针）
    Cnt_FuncParam(irc.result); // 统计函数参数空间需求
    rescan_loc = i; // 记录函数开始位置
    break;
case IR_FUNC_END:
    frame_size = up_to_align(frame_size, 16); // 栈帧大小对齐到16字节边界
    rescan = true; // 启动第二次扫描
    i = rescan_loc - 1; // 回跳到函数开始前的位置
    break;
```

此阶段的核心任务是遍历函数体内的所有变量声明，累计计算：
- 局部变量所需的栈空间
- 临时变量所需的栈空间  
- 函数参数所需的栈空间

当遇到 `IR_FUNC_END` 时，表示一个函数的第一遍扫描完成，此时将栈帧大小对齐到16字节边界（符合RISC-V ABI要求），然后重置扫描状态准备第二遍扫描。

#### 第二遍扫描：汇编代码生成
在第二遍扫描中，利用第一遍扫描获得的栈帧信息生成实际的汇编指令。系统根据中间代码的不同类型，调用相应的代码生成函数处理局部变量分配、标签生成、函数入口出口代码、参数传递、函数调用、返回语句、赋值操作、算术逻辑运算以及分支跳转等各种操作，将每种中间代码类型转换为具体的RISC-V汇编指令并写入汇编数组中，当处理完一个函数后重置扫描状态准备处理下一个函数。

#### 输出阶段
完成所有中间代码的处理后，函数将生成的汇编代码写入目标文件：
- 输出 `ASM_array` 中的汇编指令（代码段）
- 输出 `Const_Stack` 中的常量数据（数据段）

这种两遍扫描的设计巧妙地解决了栈帧大小计算的依赖问题：第一遍扫描收集信息，第二遍扫描生成代码，确保了汇编代码的正确性和完整性。

**stack_initval**

`stack_initval` 函数负责将数组或变量的初始化值转换为符合 RISC-V 汇编规范的静态数据段表示形式。

#### 功能概述
将中间代码中的初始化值字符串（如 `{1,2,3,4}` 或单个值）转换为汇编语言中的数据段指令（如 `.byte`、`.word`、`.zero` 等），并将这些指令存储到 `Const_Stack` 中，供后续汇编文件生成时使用。

#### 实现流程

**1. 字符串解析阶段**
函数首先对输入的初始化值字符串进行预处理和分割。通过去除前缀字符，然后以逗号为分隔符将字符串拆分成独立的初始化值数组：

```c++
// 将初始值字符串拆分
std::vector<std::string> initval_array;
// 去除前缀
initval_str = initval_str.substr(1);
int loc; // 第一个逗号位置
for(int i=0; i<len; i++){
    loc = initval_str.find(',');
    if(i==len-1 && loc==-1){
        // 允许最后一个没有逗号后缀
        initval_array.push_back(initval_str);
    }
    else{
        initval_array.push_back(initval_str.substr(0,loc));
        initval_str = initval_str.substr(loc+1);
    }
}
```

这个过程需要特别处理边界情况，如最后一个元素可能没有逗号后缀的情况，确保所有有效的初始化值都被正确提取。

**2. 类型判断与指令生成**
对于分割后的每个初始化值，函数根据变量的基本类型（`basety`）选择相应的汇编指令格式：

```c++
if(basety == BTY_BOOL) {
    Const_Stack.push_back(".byte   " + initval);     // 1字节
}
else if(basety == BTY_INT) {
    Const_Stack.push_back(".word   " + initval);     // 4字节
}
else if(basety == BTY_FLOAT) {
    float fval = std::stof(initval);
    int decimal_fval = *(int *)&fval;                // float转IEEE-754表示的整数
    Const_Stack.push_back(".word   " + std::to_string(decimal_fval));
}
```

- **布尔类型**：生成 `.byte` 指令，占用1字节空间，适用于布尔值和字符类型的数据
- **整数类型**：生成 `.word` 指令，占用4字节空间，直接使用原始的整数值
- **浮点类型**：将浮点数转换为IEEE-754标准的32位整数表示形式，然后生成 `.word` 指令。这种转换是必要的，因为汇编语言无法直接表示浮点常量，必须通过其二进制表示来存储

**3. 内存空间管理**
函数使用 `zero_size` 变量来跟踪和管理未初始化的内存空间：

```c++
size_t base_size = (typeutils.basety_to_size)[basety];
size_t zero_size = 0;
```

当遇到数组中的空白位置或需要对齐的空间时，会累积这些空白大小，然后通过 `.zero` 指令一次性分配相应的零初始化空间。这种设计既节省了汇编代码的长度，又确保了内存布局的正确性。


**var_to_reg**

```c++
    bool is_gvar = var_name[0] == GVAR_PREFIX;
    bool is_lvar = var_name[0] == LVAR_PREFIX;
    bool is_temp = var_name[0] == TEMP_PREFIX;
    bool is_imm = var_name[0] == IMM_PREFIX;
```

`var_to_reg` 函数负责将变量从内存（栈上或全局内存）加载到指定的寄存器中，是实现变量访问的核心函数。该函数首先通过解析变量名的前缀字符来确定变量的作用域和类型，包括全局变量（GVAR_PREFIX）、局部变量（LVAR_PREFIX）、临时变量（TEMP_PREFIX）和立即数（IMM_PREFIX）。这种基于前缀的命名约定为编译器提供了统一的变量识别机制，简化了变量分类和处理逻辑。对于数组元素或子数组访问，函数会检查变量名中是否包含特殊的中缀标识符（ADDR_INFIX表示地址偏移操作，ITEM_INFIX表示数组元素访问），当检测到这些标识符时，函数会递归调用自身，将偏移量或索引值加载到辅助寄存器s3中，为后续的地址计算做准备。

函数根据变量的数据类型（通过basety字段判断）选择合适的RISC-V加载指令：布尔/字符类型使用lb指令进行1字节加载，整数类型使用lw指令进行4字节加载，浮点类型使用flw指令进行单精度浮点加载，指针类型使用ld指令进行8字节加载。为了避免寄存器冲突，函数采用专用的寄存器分配策略，使用s3寄存器存储偏移量或索引值，使用s4寄存器进行地址计算的中间结果存储，这种分配避免了与其他函数的寄存器使用冲突。

针对不同类型的变量，函数采用不同的地址计算和加载策略：全局变量通过la指令加载全局符号地址，局部变量基于栈帧指针s0计算相对偏移，临时变量根据预先计算的栈偏移位置访问，立即数直接使用li指令加载常量值。

**reg_to_var**

`reg_to_var` 函数负责将寄存器中的值写入到变量对应的内存位置，实现了与 `var_to_reg` 相反的数据传输过程。该函数首先通过解析变量名的前缀来确定变量的作用域类型，包括全局变量（GLOBAL_PREFIX）、局部变量（LOCAL_PREFIX）和临时变量（TEMP_PREFIX）。同时检查变量名中是否包含 `ITEM_INFIX` 标识符，如果存在则表示这是一个数组元素访问，需要先将索引或偏移量加载到辅助寄存器 `s5` 中进行地址计算。

函数根据变量的数据类型和作用域采用不同的存储策略和指令选择。对于不同的数据类型，函数使用相应的 RISC-V 存储指令：双精度浮点数使用 `fsd` 指令，单精度浮点数使用 `fsw` 指令，32位整数使用 `sw` 指令，8位布尔值或字符使用 `sb` 指令。针对不同作用域的变量，全局变量通过全局符号地址进行存储，局部变量基于栈帧指针 `s0` 的相对偏移进行存储，临时变量根据预先计算的栈偏移位置进行存储。

```c++
bool is_gvar = var_name[0] == GLOBAL_PREFIX;
bool is_lvar = var_name[0] == LOCAL_PREFIX;
bool is_temp = var_name[0] == TEMP_PREFIX;
int item_infix_loc = var_name.find(ITEM_INFIX);
bool is_item = item_infix_loc != -1;
```

**Gen_FuncBegin**

`Gen_FuncBegin` 函数负责生成函数入口的汇编代码，是函数调用约定实现的核心部分。该函数在第二遍扫描遇到函数开头时被调用，主要任务是建立函数的运行环境，包括栈帧设置、寄存器保存和参数传递等关键操作。函数首先生成标准的函数标签信息，包括代码段标识（.text）、对齐指令（.align 1）、全局符号声明（.globl）、函数类型声明（.type）和函数入口标签，这些信息确保生成的汇编代码符合 RISC-V ABI 规范和链接器要求。

接下来，函数根据第一遍扫描时计算的栈帧大小生成栈帧建立指令。通过 `addi sp, sp, -frame_size` 为函数分配栈空间，然后将返回地址（ra）和帧指针（s0）保存到栈中，最后设置新的帧指针指向当前栈顶。这一系列操作建立了标准的 RISC-V 函数调用栈帧结构，为函数体的正确执行提供了必要的运行环境。

最后，函数处理参数传递过程，将存储在寄存器中的函数参数转移到栈上。根据 RISC-V 调用约定，整数参数使用 a0-a7 寄存器传递，浮点参数使用 fa0-fa7 寄存器传递。函数通过符号表查找参数列表，根据参数类型选择相应的存储指令（整数参数使用 sw/sb 指令，浮点参数使用 fsw 指令），将参数从寄存器转移到栈上的指定位置。同时，函数对参数数量进行检查，确保不超过 RISC-V ABI 规定的寄存器传递限制（各类型最多8个），如果超出限制则输出错误信息并终止程序，保证生成代码的正确性。

**Gen_FuncEnd**

`Gen_FuncEnd` 函数负责生成函数退出时的汇编代码，与 `Gen_FuncBegin` 函数形成完整的函数调用约定实现。该函数在第二遍扫描遇到函数结尾时被调用，主要任务是恢复函数调用前的运行环境，确保程序能够正确返回到调用者。

**Gen_G_Alloc**

`Gen_G_Alloc` 函数是全局变量汇编代码生成的核心函数，负责将中间代码中的全局变量声明转换为符合 RISC-V ABI 规范的汇编指令。该函数在第二遍扫描过程中被调用，当遇到全局变量分配指令时，根据变量的类型、初始化状态和存储属性，生成相应的数据段声明和内存分配指令。

函数的执行过程分为三个主要阶段：首先是变量标识解析阶段，通过解析全局变量名称获取其在符号表中的索引 `order` 和对应的汇编标签 `stack_label`。这一过程依赖于统一的变量命名规范，通过 `num_from_name` 函数从变量名中提取前缀并转换为数字索引，为后续的汇编代码生成提供必要的标识信息。其次是存储区域分配阶段，根据全局变量的属性（是否为常量、是否需要初始化）决定其在汇编文件中的存储位置：常量数据分配到只读数据段（`.rodata`），已初始化的变量分配到数据段（`.data`），未初始化的变量分配到BSS段（`.bss`）。

最后是汇编指令生成阶段，如果全局变量需要初始化，函数调用 `stack_initval` 函数解析初始值字符串，根据变量类型生成相应的汇编初始化指令（如 `.word`、`.byte` 等），确保初始值能够正确地嵌入到汇编代码中。对于未初始化的变量，函数生成 `.zero` 指令分配相应大小的零初始化空间，既节省了目标文件大小，又确保了变量的正确初始化状态。所有生成的汇编指令都被添加到 `Const_Stack` 中，最终在汇编文件输出阶段统一写入数据段。

**Gen_L_Alloc**

`Gen_L_Alloc` 函数负责处理需要初始化的局部变量，是局部变量汇编代码生成的关键函数。该函数在第二遍扫描过程中被调用，专门处理那些具有初始值的局部变量，通过在只读数据段创建常量数据，然后生成相应的汇编指令将这些初始值从数据段转移到栈上的变量位置。

函数的执行流程分为三个主要阶段：首先是变量验证与信息提取阶段，通过检查变量类型和初始化状态确定是否需要处理。如果变量不是局部变量或不需要初始化，函数直接返回，避免不必要的处理开销。对于需要处理的变量，函数调用 `num_from_name` 函数从变量名中提取索引信息，并获取变量的长度和栈偏移量，为后续的汇编代码生成做准备。

其次是数据段常量声明阶段，函数在 `.rodata` 段为局部变量的初始值创建常量数据。根据变量长度的不同，采用不同的处理策略：对于数组类型（长度大于1），统一使用标号进行初始化，确保数组元素能够正确地批量加载；对于单个变量，特别是浮点类型的常量，也需要在数据段分配标号，因为 RISC-V 架构无法直接使用立即数加载浮点值。函数还会根据数据类型生成相应的对齐指令：数组按8字节对齐，非布尔/字符类型的变量按4字节对齐，确保内存访问的效率和正确性。

最后是栈转移代码生成阶段，函数生成将常量数据从 `.rodata` 段转移到栈上的汇编指令。对于数组类型，使用寄存器 `s2` 存储标号地址，然后根据每次转移的字节数选择最优的加载/存储指令组合（8字节用 `ld`/`sd`，4字节用 `lw`/`sw`，2字节用 `lh`/`sh`，1字节用 `lb`/`sb`），通过循环结构实现高效的批量数据转移，最大化每次转移的数据量以减少指令数量。对于单个变量，根据其基本类型直接选择相应的指令将初始值存储到栈上的指定位置，确保局部变量能够正确初始化并可供后续使用。


## 总结

### 实验结果总结

本实验在前两次实验的基础上，成功实现了完整的编译器后端，完成了从中间代码到RISC-V汇编代码的转换。基于生成的中间代码，编译器能够生成符合RISC-V ABI规范的汇编代码。整个RISC-V汇编生成过程以作用域和类型为核心，配合中间变量命名规范，对变量进行统一抽象编码处理。汇编生成过程中充分考虑了RISC-V的调用约定（如s0为帧指针、全局地址通过la加载）、类型对应的指令选择（如flw对应float类型），并为数组和指针提供了灵活的偏移支持。在此过程中，我们对RISC-V指令集有了更深刻的了解，包括如何根据不同类型的变量选择对应的指令，如何用更少的指令高效实现功能。

它能够识别CACT语言格式的源文件，生成RISCV64GC平台下的汇编代码。由于本次实验复杂度高，出错的可能位置也较多，我们在充分检查代码逻辑的基础上，结合测试样例的结果进行了错误的定位和修正。通过print、gdb等方法，我们将错误定位到具体的代码语句，并进而检查中间代码和汇编代码，依次查缺补漏，从而较好地完善了整体实验。最终，汇编代码通过spike软件模拟运行，生成了正确的执行结果。

stack_initval、var_to_reg、reg_to_var等函数作为变量处理的基础函数，是连接语义分析结果与汇编生成之间的重要桥梁。编译器采用两遍扫描的策略，第一遍进行栈帧分析，第二遍生成汇编代码，巧妙地解决了栈帧大小计算的依赖问题。整个过程需要深入了解语法、语义分析过程和RISC-V指令集的指令结构，在设计中间代码时需要合理地设计数据、代码结构以便后续的优化，在生成汇编代码时也需要仔细考虑寄存器的分配和代码布局的问题。

### 分成员总结

**曾伟鸿**

在本次实验中，我主要负责了代码的设计、实现和优化工作。通过本次实验，我对编译器后端的工作原理有了更深入的理解，也加深了对RISC-V汇编以及ABI规范的认识。在实验过程中，我参与了核心算法的设计和实现，特别是在中间代码生成和汇编代码转换方面贡献了重要力量。

**叶力汗**

在本次实验中，我主要负责程序功能性和正确性的调试工作。由于实验复杂度较高，我专注于错误定位和修正，通过各种调试方法确保程序的正确运行。同时，我也参与了测试样例的验证工作，通过系统性的测试确保编译器能够正确处理各种复杂情况。

**马艺豪**

在本次实验中，我主要负责实验环境的配置和技术支持工作。我参与了编译器架构的设计讨论，协助完成了代码的实现和优化。通过本次实验，我对编译器的完整工作流程有了更清晰的认识，也巩固了C++开发语言的相关知识。总体来说，通过研讨课上的三次实验，我体会到了构建一个完整编译器的基本流程和工程实践。
